void parse_args(int argc, char *argv[], t_traceroute_options *opts) {
    int i = 1, pos_count = 0;
    // valores por defecto
    opts->n_queries = 3;
    opts->packet_len = 60;
    opts->base_port = 33434;

    while (i < argc) {
        char *arg = argv[i];
        if (arg[0] == '-' && arg[1]) {
            // es opción
            switch (arg[1]) {
            case 'q':  // -q nqueries
                if (i+1 >= argc) error_exit(..., "Missing -q arg");
                opts->n_queries = atoi(argv[++i]);
                break;
            case 'p':  // -p port
                if (i+1 >= argc) error_exit(..., "Missing -p arg");
                opts->base_port = atoi(argv[++i]);
                break;
            // … aquí tu -d, -m, -s, -N, etc. …
            default:
                error_exit(EXIT_FAILURE, 0, "Unknown option: %s", arg);
            }
            i++;
        }
        else {
            // argumento posicional
            pos_count++;
            if (pos_count == 1) {
                // primer posicional = host
                opts->target.hostname = arg;
            }
            else if (pos_count == 2) {
                // segundo posicional = packetlen
                int plen = atoi(arg);
                if (plen < 28 || plen > 65535)
                    error_exit(EXIT_FAILURE, 0,
                               "packetlen must be 28–65535"); // too big packetlen 600000 specified

                opts->packet_len = plen;
            }
            else {
                error_exit(EXIT_FAILURE, 0,
                           "Extra arg `%s' (position %d, argc %d)",
                           arg, pos_count, pos_count);
            }
            i++;
        }
    }

    if (pos_count < 1)
        error_exit(EXIT_FAILURE, 0, "Missing host argument");
}




*******************************************************************************************
size_t payload_sz = opts->payload_size_use ? opts->payload_size : PAYLOAD_SIZE;
    size_t packet_length = sizeof(t_packet) + payload_sz;
    uint64_t    now;
	ssize_t     sent_bytes;

    t_packet    *packet = malloc(packet_length);
	if (!packet) {
         print_infof(opts->verbose, stderr, "malloc failed: %s", strerror(errno));
         return (-1);
    }
    
	//  Rellenar cabecera
	memset(packet, 0, packet_length);
	packet->header.type = ICMP_ECHO;
	packet->header.code = ICMP_CODE_DEFAULT;
	packet->header.id = htons((uint16_t)getpid());
	packet->header.sequence = htons(seq);

	// Timestamp en payload
	now = ft_time_now_us();
	memcpy(packet->payload, &now, sizeof(now));

	// Rellenar resto del payload
    if (opts->pattern_use){
        for (size_t i = sizeof(now); i < payload_sz; i++)
            packet->payload[i] = opts->pattern[i % opts->pattern_len];
        if (opts->debug)
            print_pattern(opts);
    }else {
	    for (size_t i = sizeof(now); i < payload_sz; i++)
		    packet->payload[i] = 0x42; // patrón tipico
    }

	//  Calcular checksum
	packet->header.checksum = 0;
	packet->header.checksum = htons(calc_checksum(packet, packet_length));
